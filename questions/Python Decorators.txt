(Python Decorators) 1. What will be the output of the following Python code?

def mk(x):
    def mk1():
        print("Decorated")
        x()
    return mk1
def mk2():
    print("Ordinary")
p = mk(mk2)
p()

a)

Answer: d
Explanation: The code shown above first prints the word “Decorated” and then “ordinary”. Hence the output of this code is:
Decorated
Ordinary.



(Python Decorators) 2. In the following Python code, which function is the decorator?

def mk(x):
    def mk1():
        print("Decorated")
        x()
    return mk1
def mk2():
    print("Ordinary")
p = mk(mk2)
p()

a) p()
b) mk()
c) mk1()
d) mk2()


Answer: b
Explanation: In the code shown above, the function mk() is the decorator. The function which is getting decorated is mk2(). The return function is given the name p().



3. The ______ symbol along with the name of the decorator function can be placed above the definition of the function to be decorated works as an alternate way for decorating a function.
a) #
b) $
c) @
d) &


Answer: c
Explanation: The @ symbol along with the name of the decorator function can be placed above the definition of the function to be decorated works as an alternate way for decorating a function.



(Python Decorators) 4. What will be the output of the following Python code?

def ordi():
	print("Ordinary")
ordi
ordi()

a)

Answer: a
Explanation: The code shown above returns the address on the function ordi first, after which the word “Ordinary” is printed. Hence the output of this code is:
Address
Ordinary.



(Python Decorators) 5.  The two snippets of the following Python codes are equivalent.

CODE 1
  @f
def f1():
        print(“Hello”)
CODE 2
  def f1():
         print(“Hello”)
f1 = f(f1)

a) True
b) False


Answer: a
Explanation: The @ symbol can be used as an alternate way to specify a function that needs to be decorated. The output of the codes shown above is the same. Hence they are equivalent. Therefore this statement is true.



(Python Decorators) 6. What will be the output of the following Python function?

def f(p, q):
	return p%q
f(0, 2)
f(2, 0)

a)

Answer: c
Explanation: The output of f(0, 2) is 0, since o%2 is equal to 0. The output of the f(2, 0) is a Zero Division Error. We can make use of decorators in order to avoid this error.



(Python Decorators) 7. What will be the output of the following Python code?

def f(x):
    def f1(a, b):
        print("hello")
        if b==0:
            print("NO")
            return
        return f(a, b)
    return f1
@f
def f(a, b):
    return a%b
f(4,0)

a)

Answer: a
Explanation: In the code shown above, we have used a decorator in order to avoid the Zero Division Error. Hence the output of this code is:
    hello
    NO




(Python Decorators) 8. What will be the output of the following Python code?

def f(x):
    def f1(*args, **kwargs):
        print("*"* 5)
        x(*args, **kwargs)
        print("*"* 5)
    return f1
def a(x):
    def f1(*args, **kwargs):
        print("%"* 5)
        x(*args, **kwargs)
        print("%"* 5)
    return f1
@f
@a
def p(m):
    print(m)
p("hello")

a)

Answer: a
Explanation: The code shown above uses multiple decorators. The output of this code is:
    *****
    %%%%%
    hello
    %%%%%
    *****




(Python Decorators) 9. The following python code can work with ____ parameters.

def f(x):
    def f1(*args, **kwargs):
           print("Sanfoundry")
           return x(*args, **kwargs)
    return f1

a) 2
b) 1
c) any number of
d) 0


Answer: c
Explanation: The code shown above shows a general decorator which can work with any number of arguments.



(Python Decorators) 10. What will be the output of the following Python code?

def f(x):
    def f1(*args, **kwargs):
        print("*", 5)
        x(*args, **kwargs)
        print("*", 5)
    return f1
@f
def p(m):
    p(m)
print("hello")

a)

Answer: d
Explanation: In the code shown above, we have not passed any parameter to the function p. Hence the output of this code is: hello.



11. A function with parameters cannot be decorated.
a) True
b) False


Answer: b
Explanation: Any function, irrespective of whether or not it has parameters can be decorated. Hence the statement is false.



(Python Decorators) 12. Identify the decorator in the snippet of code shown below.

def sf():
     pass
sf = mk(sf)
@f
def sf():
     return

a) @f
b) f
c) sf()
d) mk


Answer: d
Explanation: In the code shown above, @sf is not a decorator but only a decorator line. The ‘@’ symbol represents the application of a decorator. The decorator here is the function mk.



(Python Decorators) 13. What will be the output of the following Python code?

class A:
    @staticmethod
    def a(x):
        print(x)
A.a(100)

a) Error
b) Warning
c) 100
d) No output


Answer: c
Explanation: The code shown above demonstrates rebinding using a static method. This can be done with or without a decorator. The output of this code will be 100.



(Python Decorators) 14. What will be the output of the following Python code?

def d(f):
    def n(*args):
        return '$' + str(f(*args))
    return n
@d
def p(a, t):
    return a + a*t 
print(p(100,0))

a) 100
b) $100
c) $0
d) 0


Answer: b
Explanation: In the code shown above, the decorator helps us to prefix the dollar sign along with the value. Since the  second argument is zero, the output of the code is: $100.



(Python Decorators) 15. What will be the output of the following Python code?

def c(f):
    def inner(*args, **kargs):
        inner.co += 1
        return f(*args, **kargs)
    inner.co = 0
    return inner
@c
def fnc():
    pass
if __name__ == '__main__':
    fnc()
    fnc()
    fnc()
    print(fnc.co)

a) 4
b) 3
c) 0
d) 1


Answer: b
Explanation: The code shown above returns the number of times a given function has been called. Hence the output of this code is: 3